## Hash란?
>해시(Hash) 란 데이터를 다루는 기법 중 하나이며,해시 함수(Hash Function) 는 데이터를 효율적으로 관리하기 위해서 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수이다.<br>
매핑전 원래 데이터의 값을 키(key), 매핑 후 데이터의 값을 해시값(Hash Value) 또는 해시코드 라고 하며, 키(key)와 값(value)으로 매핑되는 과정 자체를 해싱(Hashing) 이라고 한다.<br>
해시값 자체를 index로 사용하기 때문에 평군 시간복잡도가 O(1) 로 매우 빠르며, 해시 태이블의 크기에 상관없이 데이터에 빠르게 접근할 수 있다.<br>


<br>

## ▶️ 해시 함수, 해시 알고리즘, 해시코드?
데이터의 key값을 배열의 인덱스인 정수로 변환하기 위해서는 일련의 과정이 필요하다. 예를들어 데이터를 문자열로 받게 되었을 때 문자 한글자 한글자의 아스키 코드 값을 더하는 과정으로 문자열을 정수 값으로 변환할 수 있다. (만약, hello 라는 문자열을 정수형 key 값으로 바꾼다면, h + e + l + l + o -> 104 +101 + 108 + 108 + 111 = 532라는 해시코드로 변환 할 수 있다.)


<br>

## ▶️ 해시 함수
* 계산이 복잡하지 않고 키값에 대해 중복없이 해시값을 고르게 만들어 내는 함수가 좋은 함수 (충돌이 일어나지 않을수록 좋다)<br>
* 대표적으로 나눗셈법(Division Method)와 곱셉법(Multiplication Method)이 있다.<br>
* 좋은 해시함수의 조건은 Simple uniform hash 함수를 만드는 것으로, 조건은 다음과 같다.<br>
    * 계산된 해쉬값들은 0부터 배열의 크기-1 사이의 범위를 '동일한 확률'로 골고루 나타날 것.(충돌이 일어날 확률이 적어진다.)<br>
    * 각각의 해쉬값들은 서로 연관성을 가지지 않고 독립적으로 생성될 것.(해쉬값들이 서로 연관이 있을 경우 연관성이 있으면 해당 해쉬값이 등장하는 패턴이나 순서가 존재 할 수 있고, 이는 반복적인 충돌을 일으 킬 확률이 있기 때문에 독립적으로 생성되도록 한다.)<br>


<br>

## ▶️ 해시 테이블
해시 테이블은 키를 해시 함수(hash function) 로 계산하여 그 값을 배열의 인덱스로 사용한다. 이때, 해시 함수에 의해 반환된 데이터의 고유 숫자 값을 해시값 또는 해시코드 라고 한다. 즉, key 값을 해시 함수를 통해서 배열의 인덱스로 바꿔주고, 그 자리에 데이터를 저장한다.<br>
이름을 키(key)로 하여 번호를 저장하는 해시 테이블은 다음과 같이 만들 수 있다. 전체 데이터 양을 10이라고 하면 John의 데이터를 저장할 때, 배열의 인덱스는 hashFunction("John") % 10을 통해 인덱스 값을 계산한다. 여기서는 인덱스 값은 2이다.<br>
이런식으로 데이터를 저장하다 보면 계산된 인덱스 값이 중복될 수가 있다. 예를 들어 저장하고자 하는 키가 정수이고 hash_function이key%10이다. 전체 사이즈가10일때, key 1,11,21은 같은 인덱스 값을 가지게 된다. 이를 충돌 (collision) 이라고한다.<br>


<br>

## ▶️ 충돌(Collision)
충돌(Collision) 은 서로 다른 문자열이 Hash function을 통해 Hash 한 결과가 같은 경우 (중복되는 경우)이다.<br>
충돌을 줄여주는 좋은 해시 함수를 사용하는 것이 좋다. 왜냐하면 충돌이 많아질 수록 탐색의 시간 복잡도가 O(1)에서 O(n)에 가까워지기 때문이다. 해결 방법은 다음과 같다.<br>
* 체이닝(Separating Chaining) - Linked List, Tree(Red-Black Tree)<br>
* 개방 주소법(Open addressing) - Linear Probing, Quadratic Probing, Double hashing<br>


<br>

## ▶️ 체이닝(Separating Chaining)
* 충돌이 일어날 경우 데이터들을 포인터를 이용해 서로 링크드 리스트(체인)형태로 연결하는 것 <br>
* 충돌을 허용하되, 최소화하는 방식에 가깝다.<br>
* key값을 포인터로 이어서 연결한다.<br>
* 최악의 경우 모든 데이터가 같은 해시값을 가져 O(n)의 복잡도를 가진다.<br>
* JDK 라이브러리에 구현된 HashMap 은 chaining 방식을 사용하며 해당 버킷의 길이에 따라 LinkedList에서 Tree로 변경될수 있다.<br>
![image](https://user-images.githubusercontent.com/117061586/233939770-7151c818-6734-44d7-a493-c2b55d5996eb.png)<br>
[이미지 출처 - Hash table / wikipedia](https://en.wikipedia.org/wiki/Hash_table)<br>


<br>

## ▶️ 개방 주소법(Open addressing)
* 모든 데이터를 테이블에 저장하는 방법이다.<br>
* 사용하려는 해시 버킷(테이블)이 이미 사용중인 경우 다른 버킷을 사용한다.<br>
* 포인터를 쓰지 않아 오버헤드를 방지할 수 있고 데이터가 적을 경우 연속된 공간에 인자를 저장하기 때문에 공간 효율이 높다.<br>
* 포인터가 필요없어 구현이 훨씬 용이해졌으며, 포인터 접근에 필요한 시간이 없어졌기 때문에 큰 성능향상이 있다.<br>
* 하지만 테이블의 크기가 커질수록 장점이 사라진다.<br>
* Linear Probing<br>
    * 충돌이 발생한다면 바로 다음 인덱스에 데이터를 저장하는 방식 다음으로 이동한 이후에도 충돌이 발생했다면 또 다시 바로 다음인덱스에 저장한다.<br>
    * 삭제는 더미 노드를 넣어서 검색할 때 다음 인덱스까지 검색을 연결해주는 역할을 해줘야하기 때문에 삭제가 어렵다.
![image](https://user-images.githubusercontent.com/117061586/233941715-4c4f8f43-dfc3-4940-aab1-1f4f5732364c.png)<br>
[이미지 출처 - 해시(Hash) 란?/ HELLO RUNA!](https://runa-nam.tistory.com/84)<br>


<br>

## ▶️ 리사이징(Resizing)
체이닝의 경우, 버킷이 일정 수준으로 차 버리면 각 버킷에 연결되어 있는 List의 길이가 늘어나기 때문에, 검색 성능이 떨어지기 때문에 버킷의 개수를 늘려줘야 한다.<br>
또한 개방 주소법의 경우, 고정 크기 배열을 사용하기 때문에 데이터를 더 넣기 위해서는 배열을 확장해야 한다. 이를 리사이징(Resizing)이라고 한다.<br>
보통 두 배로 확장하는데, 확장하는 임계점은 현재 데이터 개수가 해시 버킷의 개수의 75%가 될 때이다. 0.75라는 숫자는 load factor 라고 불린다. 리사이징은 더 큰 버킷을 가지는 array를 새로 만든 다음에, 다시 새로운 array에 hash를 다시 계산해서 복사해줘야 한다.<br>


<br>

## ▶️ 해시 테이블의 장점
* 적은 리소스로 많은 데이터를 효율적으로 관리할 수 있다.<br>
    * HDD, Cloud에 존재하는 많은 데이터들을 유한한 개의 해시(Hash)값으로 매핑하여 작은 크기의 캐쉬 메모리로 프로세스 관리가 가능하다.<br>
* 배열의 인덱스(index)를 사용해서 검색, 삽입, 삭제가 빠르다. (평균 시간복잡도 : O(1))<br>
    * 인덱스를 사용해서 배열의 검색이 빠르다는 것은 당연한 소리이다. 하지만 삽입, 삭제는 왜 O(1)인가?<br>
    * 여기서의 인덱스는 데이터만의 고유한 위치이기 때문에 만약 삽입이나 삭제를 한다고 해도 다른 데이터로 채울 필요가 없다. 즉, 삽입이나 삭제할 때 데이터를 이동할 필요가 없기 때문이다.<br>
* 키(key)와 해시값(Hash)이 연관성이 없어 보안에도 많이 사용된다.<br>
* 데이터 캐싱(Data Caching)에 많이 사용된다.<br>
    * get(key), put(key)에 캐시 로직을 추가하면 자주 hit하는 데이터를 바로 찾을 수 있다.<br>
* 중복을 제거하는데 유용하다.<br>


<br>

## ▶️ 해시 테이블의 단점
* 충돌<br>
* 공간 복잡도가 커진다.<br>
* 순서가 있는 배열에는 어울리지 않는다.<br>
* 해시 함수 의존도가 높아진다.<br>


<br>

## ▶️ 해시 테이블(Hash Table) VS 해시 맵(Hash Map)
Java에서 HashTable과 HashMap의 차이는 동기화 지원 여부이다. 키(Key)에 대한 해시(Hash)값을 사용하여 값을 저장, 조회 하는 것은 동일하다.<br>

* 해시 테이블(Hash Table)<br>
    * 병렬 처리를 할 때 (동기화를 고려해야하는 상황) <br>
    * Null 값을 허용하지 않는다. <br>
* 해시 맵(Hash Map)<br>
    * 병렬 처리를 하지 않을 때 (동기화를 고려하지 않는 상황)<br>
    * Null 값을 허용한다.<br>


<br>

## ▶️ 출처 및 참조
[참조1](https://hee96-story.tistory.com/48) - Hash/HashTable/HashMap / Hee's Story<br>
[참조2](https://siyoon210.tistory.com/85) - 해시(Hash)란 무엇인가? / How to be awesome<br>
[참조3](https://runa-nam.tistory.com/84) - 해시(Hash) 란?/ HELLO RUNA!<br>
[참조4](https://en.wikipedia.org/wiki/Hash_table) - Hash table / wikipedia<br>
