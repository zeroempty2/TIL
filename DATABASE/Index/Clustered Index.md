##  프라이머리 키(PK, Primary Key)와 클러스터링 테이블 
> MySQL은 PK를 기준으로 유사한 값들이 함께 조회되는 경우가 많다는 점에서 착안하여, PK가 유사한 레코드들끼리 묶어서 저장한다.<br> 
유사한 것들을 묶는 것을 클러스터링이라고 하는데, 그래서 일반적으로 PK는 클러스터 인덱스(Clustered Index)라고도 불리며, 그 외의 일반적인 인덱스는 논클러스터 인덱스로 불린다. 

<br>

## ▶️  페이지(Page)
페이지란 디스크와 버퍼풀(메모리)에 데이터를 읽고 쓰는 최소 작업 단위이다.<br> 일반적인 인덱스를 포함해 PK(클러스터 인덱스)와 테이블 등은 모두 페이지 단위로 관리된다. 따라서 만약 쿼리를 통해 1개의 레코드를 읽고 싶더라도 결국은 하나의 블록을 읽어야 하는 것이다.<br> 

그래서 페이지에 저장되는 개별 데이터의 크기를 최대한 작게 하여, 1개의 페이지에 많은 데이터들을 저장할 수 있도록 하는 것이 상당히 중요하다.<br>페이지에 저장되는 데이터의 크기가 클수록 다음과 같은 문제가 생길 수 있다.<br> 

* 디스크 I/O가 많아질 수 있음<br> 
* 메모리에 캐싱할 수 있는 페이지의 수가 줄어들 수 있음<br> 


<br>

## ▶️ 클러스터링 테이블의 저장 방식
클러스터링 테이블이란 클러스터 인덱스를 갖는 테이블이다.<br> MySQL에서는 기본적으로 PK가 클러스터 인덱스이며, PK가 없으면 내부적으로 PK를 만들어내므로 모든 테이블이 클러스터링 테이블이라고 볼 수 있다.<br>
PK와 테이블의 저장 방식을 살펴보면 다음과 같은데, 이는 리프 노드에 실제 레코드의 모든 컬럼 값이 저장되어 있다는 점을 제외하면 일반적인 인덱스와 동일하다.
![image](https://user-images.githubusercontent.com/117061586/230721615-9e435948-cdd6-4faa-b200-b52043f412a7.png)
[이미지 출처 - 프라이머리 키(PK, Primary Key)에 대해 쉽고 완벽하게 이해하기](https://mangkyu.tistory.com/285)
<br>


<br>

## ▶️  PK와 인덱스의 관계
PK가 레코드의 물리적인 저장 위치를 결정하기 때문에, 인덱스는 PK에 의존한다. 그래야 인덱스를 타고 들어와서 PK를 통해 저장된 위치에서 레코드를 읽어올 수 있기 때문이다.<br>이러한 구조를 그림으로 표현하면 다음과 같다.<br>
![image](https://user-images.githubusercontent.com/117061586/230721823-53f0e1b4-535b-4498-bdce-5cc4761b2793.png)
[이미지 출처 - 프라이머리 키(PK, Primary Key)에 대해 쉽고 완벽하게 이해하기](https://mangkyu.tistory.com/285)<br>
인덱스가 PK가 아닌 실제 레코드의 주소를 갖게 할 수도 있다. 하지만 그렇게 구현하면 PK가 변경될 때 데이터 레코드의 주소가 변경되고, 그 때마다 모든 인덱스에 저장된 레코드의 주소를 변경해주어야 한다. <br>그러므로 이러한 오버헤드를 피하기 위해 레코드의 주소가 아닌 PK를 저장하도록 구현된 것이다.<br>
인덱스가 PK에 의존하기 때문에, 인덱스를 통해 테이블에서 데이터를 가져오려면 2번의 작업이 필요하다. 먼저 인덱스에서 인덱스 키를 통해서 PK를 찾아야 하고, 그 다음 PK를 통해서 테이블로부터 데이터를 읽어와야 한다.<br> 그렇기에 인덱스를 통해 데이터를 읽어오는 것 보다는 PK로 읽어오는게 빠르다고 볼 수 있다.


<br>

## ▶️ 클러스터 인덱스의 장점과 단점 
* 장점
    * PK로 검색할 때 처리가 매우 빠름<br>
    * 연속되는 PK로 조회할 경우 랜덤 I/O가 아닌 순차 I/O를 사용하여 처리 속도가 더욱 빠름<br>
    * 인덱스가 PK값을 가지므로 인덱스로 PK 값만 조회하는 경우 효율적으로 처리될 수 있음(=커버링 인덱스)<br>
* 단점
    * 모든 인덱스가 PK에 의존하므로 PK 값이 클 경우 전체적으로 인덱스의 크기가 커지고, 페이지 양이 많아짐<br>
    * 인덱스를 통해 검색할 때 PK로 다시 한번 검색해야 하므로 처리 성능이 느림<br>
    * INSERT 시에 PK에 의해 레코드의 저장 위치가 결정되기 때문에 처리 성능이 느림<br>
    * PK를 변경할 때 레코드를 DELETE 및 INSERT 해야 하므로 처리 성능이 느림<br>



<br>

<br>
[참조1](https://mangkyu.tistory.com/285) - 프라이머리 키(PK, Primary Key)에 대해 쉽고 완벽하게 이해하기 / 망나니 개발자 